<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>今日のやることチャレンジ</title>
  <style>
    :root{
      --bg:#fff7d6; --card:#fff; --ink:#2b2b2b;
      --shadow:0 10px 22px rgba(0,0,0,.10);
      --radius:18px;
      --pink:#ff5aa5; --blue:#3aa0ff; --green:#22c55e; --orange:#ff8a3d; --purple:#8b5cf6;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      background: var(--bg);
      color: var(--ink);
    }
    header{
      padding:18px 16px 10px;
      text-align:center;
    }
    h1{ margin:0; font-size:22px; letter-spacing:.02em; }
    .sub{ margin-top:6px; font-size:13px; opacity:.75; }

    .wrap{
      max-width: 860px;
      margin: 0 auto;
      padding: 10px 14px 26px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    @media (min-width: 860px){
      .wrap{ grid-template-columns: 1.2fr .8fr; }
    }

    .card{
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .row{ display:flex; gap:10px; align-items:center; }
    .row > *{ flex:1; }
    input[type="text"], textarea{
      width:100%;
      border: 1px solid rgba(0,0,0,.10);
      border-radius: 12px;
      padding: 12px 12px;
      font-size:16px;
      outline:none;
    }
    textarea{ min-height: 120px; resize: vertical; }
    button{
      border:0;
      border-radius: 14px;
      padding: 12px 12px;
      font-size:16px;
      font-weight:700;
      cursor:pointer;
      box-shadow: 0 8px 16px rgba(0,0,0,.10);
      transition: transform .05s ease;
    }
    button:active{ transform: translateY(1px); }
    .btnAdd{ background: var(--pink); color:#fff; }
    .btnReset{ background: rgba(0,0,0,.08); }
    .btnSmall{ padding: 10px 12px; font-size:14px; border-radius: 12px; box-shadow:none; }

    ul{ list-style:none; padding:0; margin:10px 0 0; display:flex; flex-direction:column; gap:10px; }
    .item{
      display:flex; align-items:center; gap: 10px;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,.08);
      background: rgba(0,0,0,.02);
    }
    .item.done{ opacity:.85; background: rgba(34,197,94,.10); border-color: rgba(34,197,94,.25); }
    .check{
      width: 44px; height:44px; border-radius: 14px;
      background: rgba(0,0,0,.06);
      display:grid; place-items:center;
      flex:0 0 auto;
    }
    .check input{ width:22px; height:22px; }
    .text{ flex:1; font-size:17px; }
    .btns{ display:flex; gap:8px; }
    .btnDel{ background: rgba(255,0,0,.10); color:#b00000; }
    .btnUp{ background: rgba(0,0,0,.06); }
    .btnDown{ background: rgba(0,0,0,.06); }

    .progress{
      display:flex; align-items:center; gap:10px;
      margin-top: 10px;
    }
    .bar{
      height: 16px; background: rgba(0,0,0,.08);
      border-radius: 999px; overflow:hidden; flex:1;
    }
    .bar > div{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, var(--blue), var(--green));
      border-radius: 999px;
      transition: width .2s ease;
    }
    .pct{ min-width: 60px; text-align:right; font-weight:800; }
    .stars{ font-size: 18px; letter-spacing: 2px; margin-top:6px; }

    .cheer{
      margin-top:10px;
      padding: 12px;
      border-radius: 14px;
      background: rgba(255,90,165,.12);
      border: 1px solid rgba(255,90,165,.25);
      display:none;
    }
    .cheer.show{ display:block; }

    .rewardBox{
      margin-top:10px;
      padding: 14px;
      border-radius: 16px;
      background: rgba(139,92,246,.10);
      border: 1px solid rgba(139,92,246,.25);
      display:none;
    }
    .rewardBox.show{ display:block; }
    .rewardTitle{ font-weight:900; margin:0 0 6px; }
    .rewardText{ font-size:18px; margin: 0 0 10px; }
    .muted{ font-size: 12px; opacity:.7; }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.78);
      color:#fff;
      padding: 10px 14px;
      border-radius: 999px;
      font-size: 14px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .25s ease;
      z-index: 9999;
    }
    .toast.show{ opacity: 1; }

    .warn{
      margin-top:10px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(255,138,61,.14);
      border: 1px solid rgba(255,138,61,.30);
      font-size: 13px;
      display:none;
    }
    .warn.show{ display:block; }

    .commentBox{ margin-top:10px; }
    .commentPreview{
      margin: 6px 0 0;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px dashed rgba(0,0,0,.18);
      background: rgba(0,0,0,.02);
      font-size: 13px;
      opacity: .85;
      white-space: pre-wrap;
    }
    .commentList{
      margin-top:10px;
      display:flex; flex-direction:column; gap:8px;
    }
    .commentItem{
      display:flex; gap:10px; align-items:flex-start;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,.08);
      background: rgba(0,0,0,.02);
    }
    .commentItem .cText{ flex:1; white-space: pre-wrap; }
    .commentItem .cTime{ font-size:12px; opacity:.6; margin-top:2px; }
    .commentItem .cDel{ flex: 0 0 auto; }

    #confettiLayer{ position:fixed; inset:0; pointer-events:none; z-index: 9998; }

  </style>
</head>
<body>
<header>
  <h1>今日のやることチャレンジ</h1>
  <div class="sub">全部できたら、ごほうび！</div>
</header>

<div class="wrap">
  <div class="card">
    <div class="row">
      <input id="taskInput" type="text" placeholder="やること（30文字まで）" />
      <button id="addBtn" class="btnAdd">＋ 追加</button>
      <button id="resetBtn" class="btnReset">リセット</button>
    </div>

    <div class="progress">
      <div class="bar"><div id="barFill"></div></div>
      <div class="pct" id="percent">0%</div>
    </div>
    <div class="stars" id="stars"></div>

    <div class="cheer" id="cheer">
      <div style="font-weight:900; font-size:18px;">やったー！ぜんぶできた！</div>
      <div class="muted">※達成した時間はスプレッドシートに記録されるよ（1日1回）</div>
    </div>

    <div class="rewardBox" id="rewardBox">
      <div class="rewardTitle">今日のごほうび</div>
      <p class="rewardText" id="rewardText"></p>
      <button id="hideRewardBtn" class="btnSmall">ごほうびをかくす</button>
    </div>

    <ul id="list"></ul>

    <div class="commentBox">
      <div style="display:flex; gap:10px; align-items:center; margin-top:12px;">
        <div style="font-weight:900;">メモ（160文字まで）</div>
      </div>
      <div class="row" style="margin-top:8px;">
        <input id="commentInput" type="text" placeholder="できたこと・がんばったことを書こう" />
        <button id="commentAddBtn" class="btnSmall" style="background: var(--blue); color:#fff;">追加</button>
      </div>
      <div class="commentPreview" id="commentPreview"></div>
      <div class="commentList" id="commentList"></div>
    </div>

    <div class="warn" id="storageWarn">この環境では保存がうまくいかないかも…（でも使えるよ）</div>
  </div>

  <div class="card">
    <div style="font-weight:900; font-size:18px;">ごほうび編集（1行に1つ）</div>
    <div class="muted">例：ゲーム10分 / アイス1こ / えいが1本 など</div>
    <textarea id="rewardsInput" placeholder="ごほうびを入力"></textarea>
    <div class="row" style="margin-top:10px;">
      <button id="saveRewardsBtn" class="btnSmall" style="background: var(--purple); color:#fff;">保存</button>
      <button id="resetRewardsBtn" class="btnSmall">初期に戻す</button>
    </div>
  </div>
</div>

<div id="confettiLayer"></div>
<div class="toast" id="toast"></div>

<script>
(async () => {

  // ====== かんたんユーティリティ ======
  const memStore = {};
  const STORAGE_OK = (() => {
    try{
      const k="__t__"; localStorage.setItem(k,"1"); localStorage.removeItem(k);
      return true;
    }catch{
      return false;
    }
  })();

  function toast(msg){
    const elToast = document.getElementById("toast");
    elToast.textContent = msg;
    elToast.classList.add("show");
    clearTimeout(toast._t);
    toast._t = setTimeout(() => elToast.classList.remove("show"), 1200);
  }

  function makeId(){
    return Math.random().toString(36).slice(2) + Date.now().toString(36);
  }

  function loadJson(key){
    try{
      const raw = STORAGE_OK ? localStorage.getItem(key) : (key in memStore ? JSON.stringify(memStore[key]) : null);
      if(!raw) return null;
      return JSON.parse(raw);
    }catch{
      return null;
    }
  }

  // ★API（GAS Webアプリ）ここを差し替えてください
  const API_URL = "https://script.google.com/macros/s/AKfycbxVT20cF2cEQwbXWEn4_MlvKBDAq9YTW6mcewmPz8imWyrR39MnuqdPxQ9ZXO9Q91JG/exec";
  const API_TOKEN = "kids-2026-0130-asahi-0620";

  async function apiPost(payload){
    try{
      const res = await fetch(API_URL, {
        method: "POST",
        headers: { "Content-Type": "text/plain;charset=utf-8" },
        body: JSON.stringify({ token: API_TOKEN, ...payload })
      });
      return await res.json();
    }catch(err){
      return { ok:false, error: String(err?.message || err) };
    }
  }

  async function remotePing(){
    try{
      const url = `${API_URL}?mode=ping&token=${encodeURIComponent(API_TOKEN)}&_=${Date.now()}`;
      const res = await fetch(url, { cache: "no-store" });
      return res.ok;
    }catch{
      return false;
    }
  }

  async function remoteLoadAll(){
    try{
      const url = `${API_URL}?mode=loadAll&token=${encodeURIComponent(API_TOKEN)}&_=${Date.now()}`;
      const res = await fetch(url, { cache: "no-store" });
      const j = await res.json();
      if(j && j.ok) return j;
      return null;
    }catch{
      return null;
    }
  }

  async function remoteSet(key, value){
    await apiPost({ mode:"save", key, data: value });
  }

  async function remoteLogAchievement(info){
    // info: { date, ts, taskCount }
    return await apiPost({ mode:"logAchievement", ...info });
  }

  function ymdLocal(d){
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${day}`;
  }

  function recordAchievementOncePerDay(taskCount){
    const today = ymdLocal(new Date());
    try{
      if(STORAGE_OK){
        if(localStorage.getItem(KEY_LAST_ACHIEVE_DATE) === today) return;
      }else{
        if(memStore[KEY_LAST_ACHIEVE_DATE] === today) return;
      }
    }catch{}

    remoteLogAchievement({ date: today, ts: Date.now(), taskCount })
      .then(r => {
        if(r && r.ok){
          try{
            if(STORAGE_OK) localStorage.setItem(KEY_LAST_ACHIEVE_DATE, today);
            else memStore[KEY_LAST_ACHIEVE_DATE] = today;
          }catch{}
        }
      })
      .catch(()=>{});
  }

  function saveJson(key, value){
    try{
      if(STORAGE_OK){
        localStorage.setItem(key, JSON.stringify(value));
      }else{
        memStore[key] = value;
      }
    }catch{}
    // ★操作した時だけサーバーへ保存
    remoteSet(key, value);
  }

  const KEY_TASKS = "kid_challenge_tasks_v3";
  const KEY_REWARDS = "kid_challenge_rewards_v3";
  const KEY_LAST_REWARD = "kid_challenge_last_reward_v3";
  const KEY_SHOWN_REWARD = "kid_challenge_shown_reward_v3";
  const KEY_LAST_ACHIEVE_DATE = "kid_challenge_last_achieve_date_v1";
  const KEY_COMMENTS = "kid_challenge_comments_v2";

  function sanitizeText(s){
    return String(s).trim().replace(/\s+/g, " ").slice(0, 30);
  }
  function sanitizeComment(s){
    return String(s ?? "").replace(/\r/g, "").trim().replace(/\s+/g, " ").slice(0, 160);
  }

  // --- ローカル（即表示用） ---
  let tasks = loadJson(KEY_TASKS);
  if(!Array.isArray(tasks)) tasks = [
    { id: makeId(), text: "しゅくだい", done: false },
    { id: makeId(), text: "明日のじゅんび", done: false },
    { id: makeId(), text: "おてつだい（お皿はこび）", done: false },
  ];
  tasks = tasks.filter(x => x && typeof x.text === "string").map(x => ({
    id: String(x.id ?? makeId()),
    text: sanitizeText(x.text),
    done: Boolean(x.done)
  }));

  let rewards = loadJson(KEY_REWARDS);
  if(!Array.isArray(rewards)) rewards = [
    "ゲーム10分＋","アイス（1つ）","いっしょに映画（1本）",
    "すきなおやつタイム","おふろであわあわタイム","あしたのあさ、5分だけゴロゴロOK"
  ];
  rewards = rewards.map(x => String(x).trim()).filter(x => x.length > 0).slice(0, 50);

  let comments = loadJson(KEY_COMMENTS);
  if(!Array.isArray(comments)) comments = [];
  comments = comments
    .filter(x => x && typeof x.text === "string")
    .map(x => ({ id: String(x.id ?? makeId()), text: sanitizeComment(x.text), ts: Number(x.ts ?? Date.now()) }))
    .filter(x => x.text.length > 0)
    .slice(0, 50);

  // DOM
  const elList = document.getElementById("list");
  const elInput = document.getElementById("taskInput");
  const elAdd = document.getElementById("addBtn");
  const elReset = document.getElementById("resetBtn");
  const elPercent = document.getElementById("percent");
  const elBar = document.getElementById("barFill");
  const elStars = document.getElementById("stars");
  const elCheer = document.getElementById("cheer");

  const elRewardBox = document.getElementById("rewardBox");
  const elRewardText = document.getElementById("rewardText");
  const elHideReward = document.getElementById("hideRewardBtn");

  const elRewardsInput = document.getElementById("rewardsInput");
  const elSaveRewards = document.getElementById("saveRewardsBtn");
  const elResetRewards = document.getElementById("resetRewardsBtn");

  const elWarn = document.getElementById("storageWarn");
  const elConfetti = document.getElementById("confettiLayer");

  const elCommentInput = document.getElementById("commentInput");
  const elCommentAdd = document.getElementById("commentAddBtn");
  const elCommentPreview = document.getElementById("commentPreview");
  const elCommentList = document.getElementById("commentList");

  function getProgress(){
    const total = tasks.length;
    const done = tasks.filter(t => t.done).length;
    const pct = total === 0 ? 0 : Math.round((done / total) * 100);
    const allDone = total > 0 && done === total;
    return { total, done, pct, allDone };
  }

  function pickReward(){
    if(!rewards || rewards.length === 0) return "ごほうびがないよ！(へんしゅうしてね)";
    return rewards[Math.floor(Math.random() * rewards.length)];
  }

  function showReward(forceNew){
    if(!STORAGE_OK){
      elRewardBox.classList.add("show");
      elRewardText.textContent = pickReward();
      return;
    }
    if(forceNew){
      localStorage.setItem(KEY_LAST_REWARD, pickReward());
      localStorage.setItem(KEY_SHOWN_REWARD, "1");
    }
    const reward = localStorage.getItem(KEY_LAST_REWARD) || pickReward();
    elRewardText.textContent = reward;
    elRewardBox.classList.toggle("show", localStorage.getItem(KEY_SHOWN_REWARD) !== "0");
  }

  function launchConfetti(){
    elConfetti.innerHTML = "";
    const n = 140;
    for(let i=0;i<n;i++){
      const s = document.createElement("div");
      s.style.position="absolute";
      s.style.left = Math.random()*100 + "%";
      s.style.top = "-10px";
      s.style.width = (6 + Math.random()*8) + "px";
      s.style.height = (10 + Math.random()*16) + "px";
      const colors = ["#ff5aa5","#3aa0ff","#22c55e","#ff8a3d","#8b5cf6"];
      s.style.background = colors[Math.floor(Math.random()*colors.length)];
      s.style.opacity = "0.95";
      s.style.borderRadius = "3px";
      s.style.transform = "rotate(" + (Math.random()*80 - 40) + "deg)";
      const dur = 900 + Math.random()*900;
      const delay = Math.random()*150;
      s.animate([
        { transform: s.style.transform + " translateY(0)", top:"-10px" },
        { transform: s.style.transform + " translateY(120vh)", top:"120%" }
      ], { duration: dur, delay, easing: "cubic-bezier(.2,.7,.2,1)", fill:"forwards" });
      elConfetti.appendChild(s);
    }
    setTimeout(()=> elConfetti.innerHTML="", 1400);
  }

  function renderComments(){
    elCommentList.innerHTML = "";
    if(comments.length === 0){
      elCommentPreview.textContent = "まだメモはないよ";
      return;
    }
    elCommentPreview.textContent = comments[0].text;

    for(const c of comments){
      const wrap = document.createElement("div");
      wrap.className = "commentItem";

      const left = document.createElement("div");
      left.style.flex = "1";

      const txt = document.createElement("div");
      txt.className = "cText";
      txt.textContent = c.text;

      const time = document.createElement("div");
      time.className = "cTime";
      const d = new Date(Number(c.ts || Date.now()));
      time.textContent = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")} ${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}`;

      left.appendChild(txt);
      left.appendChild(time);

      const del = document.createElement("button");
      del.className = "btnSmall btnDel cDel";
      del.textContent = "削除";
      del.addEventListener("click", () => {
        comments = comments.filter(x => x.id !== c.id);
        saveJson(KEY_COMMENTS, comments);
        render();
      });

      wrap.appendChild(left);
      wrap.appendChild(del);
      elCommentList.appendChild(wrap);
    }
  }

  let lastAllDone = false;

  function render(){
    elList.innerHTML = "";

    if(tasks.length === 0){
      const li = document.createElement("li");
      li.className = "item";
      li.innerHTML = `<div class="text">まずは「＋ 追加」してね！</div>`;
      elList.appendChild(li);
    }else{
      for(const t of tasks){
        const li = document.createElement("li");
        li.className = "item" + (t.done ? " done" : "");

        const check = document.createElement("div");
        check.className = "check";
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = t.done;
        cb.addEventListener("change", () => {
          t.done = cb.checked;
          saveJson(KEY_TASKS, tasks);
          toast(STORAGE_OK ? "保存したよ！" : "保存できないけど動いてるよ！");
          render();
        });
        check.appendChild(cb);

        const text = document.createElement("div");
        text.className = "text";
        text.textContent = t.text;

        const btns = document.createElement("div");
        btns.className = "btns";

        const up = document.createElement("button");
        up.className = "btnSmall btnUp";
        up.textContent = "↑";
        up.addEventListener("click", () => {
          const i = tasks.findIndex(x => x.id === t.id);
          if(i > 0){
            const tmp = tasks[i-1]; tasks[i-1] = tasks[i]; tasks[i] = tmp;
            saveJson(KEY_TASKS, tasks);
            render();
          }
        });

        const down = document.createElement("button");
        down.className = "btnSmall btnDown";
        down.textContent = "↓";
        down.addEventListener("click", () => {
          const i = tasks.findIndex(x => x.id === t.id);
          if(i >= 0 && i < tasks.length-1){
            const tmp = tasks[i+1]; tasks[i+1] = tasks[i]; tasks[i] = tmp;
            saveJson(KEY_TASKS, tasks);
            render();
          }
        });

        const del = document.createElement("button");
        del.className = "btnSmall btnDel";
        del.textContent = "削除";
        del.addEventListener("click", () => {
          tasks = tasks.filter(x => x.id !== t.id);
          saveJson(KEY_TASKS, tasks);
          render();
        });

        btns.appendChild(up);
        btns.appendChild(down);
        btns.appendChild(del);

        li.appendChild(check);
        li.appendChild(text);
        li.appendChild(btns);
        elList.appendChild(li);
      }
    }

    const { pct, allDone } = getProgress();
    elPercent.textContent = pct + "%";
    elBar.style.width = pct + "%";

    const stars = 5;
    const filled = Math.round((pct / 100) * stars);
    elStars.innerHTML = "";
    for(let i=0;i<stars;i++){
      const sp = document.createElement("span");
      sp.textContent = i < filled ? "★" : "☆";
      elStars.appendChild(sp);
    }

    elCheer.classList.toggle("show", allDone);
    renderComments();

    if(allDone && !lastAllDone){
      launchConfetti();
      // ★全タスク達成の時間を記録（1日1回）
      recordAchievementOncePerDay(tasks.length);
    }
    lastAllDone = allDone;

    if(allDone){
      if(STORAGE_OK){
        if(!localStorage.getItem(KEY_LAST_REWARD)) localStorage.setItem(KEY_LAST_REWARD, pickReward());
        if(localStorage.getItem(KEY_SHOWN_REWARD) !== "0") localStorage.setItem(KEY_SHOWN_REWARD, "1");
      }
      showReward(false);
    }else{
      elRewardBox.classList.remove("show");
      if(STORAGE_OK){
        localStorage.removeItem(KEY_LAST_REWARD);
        localStorage.setItem(KEY_SHOWN_REWARD, "0");
      }
    }
  }

  // イベント
  elAdd.addEventListener("click", () => {
    const text = sanitizeText(elInput.value);
    if(!text){ toast("なにをする？"); return; }
    tasks.unshift({ id: makeId(), text, done:false });
    elInput.value = "";
    saveJson(KEY_TASKS, tasks);
    render();
  });

  elInput.addEventListener("keydown", (e) => {
    if(e.key === "Enter") elAdd.click();
  });

  elReset.addEventListener("click", () => {
    if(!confirm("ぜんぶ けして いい？")) return;
    tasks = tasks.map(t => ({ ...t, done:false }));
    comments = [];
    saveJson(KEY_TASKS, tasks);
    saveJson(KEY_COMMENTS, comments);
    if(STORAGE_OK){
      localStorage.removeItem(KEY_LAST_REWARD);
      localStorage.setItem(KEY_SHOWN_REWARD, "0");
    }
    render();
  });

  elHideReward.addEventListener("click", () => {
    if(STORAGE_OK) localStorage.setItem(KEY_SHOWN_REWARD, "0");
    elRewardBox.classList.remove("show");
  });

  elSaveRewards.addEventListener("click", () => {
    const lines = elRewardsInput.value.split("\n").map(s => s.trim()).filter(Boolean).slice(0,50);
    if(lines.length === 0){ toast("1行に1つ、入れてね！"); return; }
    rewards = lines;
    saveJson(KEY_REWARDS, rewards);
    if(STORAGE_OK) localStorage.removeItem(KEY_LAST_REWARD);
    toast(STORAGE_OK ? "ごほうび保存OK！" : "保存できない環境かも！");
    if(getProgress().allDone) showReward(true);
  });

  elResetRewards.addEventListener("click", () => {
    rewards = [
      "ゲーム10分＋","アイス（1つ）","いっしょに映画（1本）",
      "すきなおやつタイム","おふろであわあわタイム","あしたのあさ、5分だけゴロゴロOK"
    ];
    elRewardsInput.value = rewards.join("\n");
    saveJson(KEY_REWARDS, rewards);
    if(STORAGE_OK) localStorage.removeItem(KEY_LAST_REWARD);
    toast("もとに戻したよ！");
    if(getProgress().allDone) showReward(true);
  });

  elCommentAdd.addEventListener("click", () => {
    const text = sanitizeComment(elCommentInput.value);
    if(!text){ toast("メモを書いてね"); return; }
    comments.unshift({ id: makeId(), text, ts: Date.now() });
    comments = comments.slice(0, 50);
    elCommentInput.value = "";
    saveJson(KEY_COMMENTS, comments);
    render();
  });

  elCommentInput.addEventListener("keydown", (e) => {
    if(e.key === "Enter") elCommentAdd.click();
  });

  // ---- 初期表示：即 render（真っ白時間をなくす）----
  elRewardsInput.value = rewards.join("\n");

  // ★起動直後は「共有の上書き」を防ぐため、ここではローカル保存だけ（GASへは送らない）
  try{ if(STORAGE_OK) localStorage.setItem(KEY_TASKS, JSON.stringify(tasks)); else memStore[KEY_TASKS]=tasks; }catch{}
  try{ if(STORAGE_OK) localStorage.setItem(KEY_REWARDS, JSON.stringify(rewards)); else memStore[KEY_REWARDS]=rewards; }catch{}
  try{ if(STORAGE_OK) localStorage.setItem(KEY_COMMENTS, JSON.stringify(comments)); else memStore[KEY_COMMENTS]=comments; }catch{}

  elWarn.classList.toggle("show", !STORAGE_OK);
  render();

  // ---- 同期（loadAll）----
  let lastUpdatedAt = 0;

  function applyAll(all){
    if(Array.isArray(all.tasks)){
      const nt = all.tasks.filter(x => x && typeof x.text === "string").map(x => ({
        id: String(x.id ?? makeId()),
        text: sanitizeText(x.text),
        done: Boolean(x.done)
      }));
      tasks = nt;
      try{ if(STORAGE_OK) localStorage.setItem(KEY_TASKS, JSON.stringify(tasks)); else memStore[KEY_TASKS]=tasks; }catch{}
    }

    if(Array.isArray(all.comments)){
      const nc = all.comments
        .filter(x => x && typeof x.text === "string")
        .map(x => ({ id: String(x.id ?? makeId()), text: sanitizeComment(x.text), ts: Number(x.ts ?? Date.now()) }))
        .filter(x => x.text.length > 0)
        .slice(0, 50);
      comments = nc;
      try{ if(STORAGE_OK) localStorage.setItem(KEY_COMMENTS, JSON.stringify(comments)); else memStore[KEY_COMMENTS]=comments; }catch{}
    }

    if(Array.isArray(all.rewards)){
      const nr = all.rewards.map(x => String(x).trim()).filter(x => x.length > 0).slice(0,50);
      rewards = nr;
      try{ if(STORAGE_OK) localStorage.setItem(KEY_REWARDS, JSON.stringify(rewards)); else memStore[KEY_REWARDS]=rewards; }catch{}
      elRewardsInput.value = rewards.join("\n");
    }

    render();
  }

  async function warmUpThenLoadAll(){
    for(let i=0;i<3;i++){
      const ok = await remotePing();
      if(ok) break;
      await new Promise(r => setTimeout(r, 400));
    }
    return await remoteLoadAll();
  }

  let keepAliveTimer = null;
  function keepAliveInterval(){
    return document.hidden ? 10 * 60 * 1000 : 3 * 60 * 1000;
  }
  function scheduleKeepAlive(){
    clearTimeout(keepAliveTimer);
    keepAliveTimer = setTimeout(async () => {
      await remotePing();
      scheduleKeepAlive();
    }, keepAliveInterval());
  }

  let fail = 0;
  let pollTimer = null;

  function baseInterval(){
    return document.hidden ? 20000 : 2000;
  }
  function backoff(ms){
    if(fail >= 4) return Math.max(ms, 10000);
    if(fail >= 2) return Math.max(ms, 5000);
    return ms;
  }

  async function tick(){
    const j = await remoteLoadAll();
    if(j && typeof j.updatedAt === "number"){
      fail = 0;
      if(j.updatedAt !== lastUpdatedAt){
        lastUpdatedAt = j.updatedAt;
        if(j.data && typeof j.data === "object"){
          applyAll(j.data);
        }
      }
    }else{
      fail = Math.min(fail + 1, 6);
    }

    const ms = backoff(baseInterval());
    clearTimeout(pollTimer);
    pollTimer = setTimeout(tick, ms);
  }

  document.addEventListener("visibilitychange", () => {
    clearTimeout(pollTimer);
    pollTimer = setTimeout(tick, 50);
    scheduleKeepAlive();
  });

  // 起動時：まず温めてから初回loadAll
  scheduleKeepAlive();
  const first = await warmUpThenLoadAll();
  if(first && typeof first.updatedAt === "number"){
    lastUpdatedAt = first.updatedAt;
    if(first.data) applyAll(first.data);

    // ★サーバー側が空（初回）なら、いまの初期データを1回だけ保存して“共有の元データ”を作る
    const hasAny = !!(first.data && (
      Array.isArray(first.data.tasks) ||
      Array.isArray(first.data.rewards) ||
      Array.isArray(first.data.comments)
    ));

    if(!hasAny || first.updatedAt === 0){
      await remoteSet(KEY_TASKS, tasks);
      await remoteSet(KEY_REWARDS, rewards);
      await remoteSet(KEY_COMMENTS, comments);

      // 保存直後の updatedAt を取り直して、以降のポーリング判定を正しくする
      const after = await remoteLoadAll();
      if(after && typeof after.updatedAt === "number"){
        lastUpdatedAt = after.updatedAt;
      }
    }
  }

  // 継続ポーリング開始
  tick();

})();
</script>
</body>
</html>
